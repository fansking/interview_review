## 力扣高效题解

主要思想就是，能用$O(n)$就解决，即使使用多个哈希表或者其他数据结构都可以。

### 两数之和

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>

~~~python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        myDict ={}
        for i in range(0,len(nums)):
            res1 =nums[i]
            res2 = target-nums[i]
            if res2 not in myDict.keys():
                myDict[res1]=i
            else:
                return [myDict[res2],i]
~~~

这道题的关键点在于使用哈希表加速搜索，通常暴力解法将所有的结果列举出来有$O(n^2)$然而这显然不符合面试官的需求，所以我们需要相处时间复杂度为$O(n)$的解法，这就要求我们能***快速找到符合条件的值***，毫无疑问哈希表是最好的选择。

### 两数相加

> 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
>
> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
>
> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> ```
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807
> ```

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        flag =0
        p = ListNode(0)
        res = p
        while l1 is not None and l2 is not None:
            nowNode = None
            nowVal = l1.val+l2.val+flag
            if nowVal//10 ==0:
                nowNode = ListNode(nowVal)
                flag =0
            else:
                nowNode = ListNode(nowVal%10)
                flag=1
            p.next =nowNode
            p=p.next
            l1=l1.next
            l2=l2.next
        if l1 is not None:
            while l1 is not None:
                nowNode = None
                nowVal = l1.val+flag
            	if nowVal//10 ==0:
                	nowNode = ListNode(nowVal)
                	flag =0
            	else:
                	nowNode = ListNode(nowVal%10)
                	flag=1
            	p.next =nowNode
            	p=p.next
            	l1=l1.next
            
            
        if l2 is not None:
            while l2 is not None:
                nowNode = None
                nowVal = l2.val+flag
            	if nowVal//10 ==0:
                	nowNode = ListNode(nowVal)
                	flag =0
            	else:
                	nowNode = ListNode(nowVal%10)
                	flag=1
            	p.next =nowNode
            	p=p.next
            	l2=l2.next
        if flag ==1:
            p.next =ListNode(1)
        return res.next
                
~~~

本题相比于面试题常见的正序存储，少一个翻转链表的过程因此较为简单。但我稍微智障，代码有点长，看到官方题解中有 x= 0 if l1 is None else l1.val    。这样可以将下面的l1和l2的单独操作去掉，不过其实空间复杂度和时间复杂度是一样的。

### 无重复字符的最长子串

> 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

~~~python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s)==0:
            return 0
        maxLen=1
        now={}
        i=0
        for j in range(0,len(s)):
            if s[j] in now:
                i = max(now[s[j]],i)
            maxLen=max(maxLen,j-i+1)
            now[s[j]]=j+1
        return maxLen
~~~

now这个哈希表中储存的是这个字符的右邻居索引。