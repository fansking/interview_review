## åŠ›æ‰£é«˜æ•ˆé¢˜è§£

ä¸»è¦æ€æƒ³å°±æ˜¯ï¼Œèƒ½ç”¨$O(n)$å°±è§£å†³ï¼Œå³ä½¿ä½¿ç”¨å¤šä¸ªå“ˆå¸Œè¡¨æˆ–è€…å…¶ä»–æ•°æ®ç»“æ„éƒ½å¯ä»¥ã€‚

### ä¸¤æ•°ä¹‹å’Œ

> ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å€¼ targetï¼Œè¯·ä½ åœ¨è¯¥æ•°ç»„ä¸­æ‰¾å‡ºå’Œä¸ºç›®æ ‡å€¼çš„é‚£ ä¸¤ä¸ª æ•´æ•°ï¼Œå¹¶è¿”å›ä»–ä»¬çš„æ•°ç»„ä¸‹æ ‡ã€‚ä½ å¯ä»¥å‡è®¾æ¯ç§è¾“å…¥åªä¼šå¯¹åº”ä¸€ä¸ªç­”æ¡ˆã€‚ä½†æ˜¯ï¼Œä½ ä¸èƒ½é‡å¤åˆ©ç”¨è¿™ä¸ªæ•°ç»„ä¸­åŒæ ·çš„å…ƒç´ ã€‚
>

~~~python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        myDict ={}
        for i in range(0,len(nums)):
            res1 =nums[i]
            res2 = target-nums[i]
            if res2 not in myDict.keys():
                myDict[res1]=i
            else:
                return [myDict[res2],i]
~~~

è¿™é“é¢˜çš„å…³é”®ç‚¹åœ¨äºä½¿ç”¨å“ˆå¸Œè¡¨åŠ é€Ÿæœç´¢ï¼Œé€šå¸¸æš´åŠ›è§£æ³•å°†æ‰€æœ‰çš„ç»“æœåˆ—ä¸¾å‡ºæ¥æœ‰$O(n^2)$ç„¶è€Œè¿™æ˜¾ç„¶ä¸ç¬¦åˆé¢è¯•å®˜çš„éœ€æ±‚ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç›¸å¤„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$çš„è§£æ³•ï¼Œè¿™å°±è¦æ±‚æˆ‘ä»¬èƒ½***å¿«é€Ÿæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å€¼***ï¼Œæ¯«æ— ç–‘é—®å“ˆå¸Œè¡¨æ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚

### ä¸¤æ•°ç›¸åŠ 

> ç»™å‡ºä¸¤ä¸ª éç©º çš„é“¾è¡¨ç”¨æ¥è¡¨ç¤ºä¸¤ä¸ªéè´Ÿçš„æ•´æ•°ã€‚å…¶ä¸­ï¼Œå®ƒä»¬å„è‡ªçš„ä½æ•°æ˜¯æŒ‰ç…§ é€†åº çš„æ–¹å¼å­˜å‚¨çš„ï¼Œå¹¶ä¸”å®ƒä»¬çš„æ¯ä¸ªèŠ‚ç‚¹åªèƒ½å­˜å‚¨ ä¸€ä½ æ•°å­—ã€‚
>
> å¦‚æœï¼Œæˆ‘ä»¬å°†è¿™ä¸¤ä¸ªæ•°ç›¸åŠ èµ·æ¥ï¼Œåˆ™ä¼šè¿”å›ä¸€ä¸ªæ–°çš„é“¾è¡¨æ¥è¡¨ç¤ºå®ƒä»¬çš„å’Œã€‚
>
> æ‚¨å¯ä»¥å‡è®¾é™¤äº†æ•°å­— 0 ä¹‹å¤–ï¼Œè¿™ä¸¤ä¸ªæ•°éƒ½ä¸ä¼šä»¥ 0 å¼€å¤´ã€‚
>
> ```
> è¾“å…¥ï¼š(2 -> 4 -> 3) + (5 -> 6 -> 4)
> è¾“å‡ºï¼š7 -> 0 -> 8
> åŸå› ï¼š342 + 465 = 807
> ```

~~~python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        flag =0
        p = ListNode(0)
        res = p
        while l1 is not None and l2 is not None:
            nowNode = None
            nowVal = l1.val+l2.val+flag
            if nowVal//10 ==0:
                nowNode = ListNode(nowVal)
                flag =0
            else:
                nowNode = ListNode(nowVal%10)
                flag=1
            p.next =nowNode
            p=p.next
            l1=l1.next
            l2=l2.next
        if l1 is not None:
            while l1 is not None:
                nowNode = None
                nowVal = l1.val+flag
            	if nowVal//10 ==0:
                	nowNode = ListNode(nowVal)
                	flag =0
            	else:
                	nowNode = ListNode(nowVal%10)
                	flag=1
            	p.next =nowNode
            	p=p.next
            	l1=l1.next
            
            
        if l2 is not None:
            while l2 is not None:
                nowNode = None
                nowVal = l2.val+flag
            	if nowVal//10 ==0:
                	nowNode = ListNode(nowVal)
                	flag =0
            	else:
                	nowNode = ListNode(nowVal%10)
                	flag=1
            	p.next =nowNode
            	p=p.next
            	l2=l2.next
        if flag ==1:
            p.next =ListNode(1)
        return res.next
                
~~~

æœ¬é¢˜ç›¸æ¯”äºé¢è¯•é¢˜å¸¸è§çš„æ­£åºå­˜å‚¨ï¼Œå°‘ä¸€ä¸ªç¿»è½¬é“¾è¡¨çš„è¿‡ç¨‹å› æ­¤è¾ƒä¸ºç®€å•ã€‚ä½†æˆ‘ç¨å¾®æ™ºéšœï¼Œä»£ç æœ‰ç‚¹é•¿ï¼Œçœ‹åˆ°å®˜æ–¹é¢˜è§£ä¸­æœ‰ x= 0 if l1 is None else l1.val    ã€‚è¿™æ ·å¯ä»¥å°†ä¸‹é¢çš„l1å’Œl2çš„å•ç‹¬æ“ä½œå»æ‰ï¼Œä¸è¿‡å…¶å®ç©ºé—´å¤æ‚åº¦å’Œæ—¶é—´å¤æ‚åº¦æ˜¯ä¸€æ ·çš„ã€‚

### æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

> ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„ **æœ€é•¿å­ä¸²** çš„é•¿åº¦ã€‚

~~~python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if len(s)==0:
            return 0
        maxLen=1
        now={}
        i=0
        for j in range(0,len(s)):
            if s[j] in now:
                i = max(now[s[j]],i)
            maxLen=max(maxLen,j-i+1)
            now[s[j]]=j+1
        return maxLen
~~~

æ¯æ¬¡çœ‹åˆ°è¿™ç§é¢˜å°±è¦æƒ³èƒ½ä¸èƒ½ç”¨$O(n)$çš„æ—¶é—´å¤æ‚åº¦å®Œæˆï¼Œå³ä¸€éæ‰«æå®Œæˆè§£é¢˜ã€‚nowè¿™ä¸ªå“ˆå¸Œè¡¨ä¸­å‚¨å­˜çš„æ˜¯è¿™ä¸ªå­—ç¬¦çš„å³é‚»å±…ç´¢å¼•ã€‚é¦–å…ˆä»å·¦å‘å³æŸ¥æ‰¾ï¼Œè®°å½•æ¯ä¸€ä¸ªå­—ç¬¦çš„å³é‚»å±…ï¼Œå¹¶ä¿®æ­£æœ€å¤§é•¿åº¦ã€‚ç›´åˆ°é‡åˆ°é‡å¤å­—ç¬¦åˆ™ä¿®æ­£å­å­—ç¬¦ä¸²çš„èµ·å§‹ä½ç½®i,åŒæ—¶ä¿®æ­£æœ€å¤§é•¿åº¦ã€‚

### å¯»æ‰¾ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°

> ç»™å®šä¸¤ä¸ªå¤§å°ä¸º m å’Œ n çš„æœ‰åºæ•°ç»„ nums1 å’Œ nums2ã€‚
>
> è¯·ä½ æ‰¾å‡ºè¿™ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­ä½æ•°ï¼Œå¹¶ä¸”è¦æ±‚ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(log(m + n))ã€‚
>
> ä½ å¯ä»¥å‡è®¾ nums1 å’Œ nums2 ä¸ä¼šåŒæ—¶ä¸ºç©ºã€‚
>

~~~python
def median(A, B):
    m, n = len(A), len(B)
    if m > n:
        A, B, m, n = B, A, n, m
    if n == 0:
        raise ValueError

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and B[j-1] > A[i]:
            # i is too small, must increase it
            imin = i + 1
        elif i > 0 and A[i-1] > B[j]:
            # i is too big, must decrease it
            imax = i - 1
        else:
            # i is perfect

            if i == 0: max_of_left = B[j-1]
            elif j == 0: max_of_left = A[i-1]
            else: max_of_left = max(A[i-1], B[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m: min_of_right = B[j]
            elif j == n: min_of_right = A[i]
            else: min_of_right = min(A[i], B[j])

            return (max_of_left + min_of_right) / 2.0
~~~

é¦–å…ˆçœ‹åˆ°è¦æ±‚æ—¶é—´å¤æ‚åº¦æ˜¯log(m+n)å°±æƒ³åˆ°ä¸€å®šä½¿ç”¨äºŒåˆ†æ³•è§£é¢˜ã€‚æ•…å¯ä»¥åˆ†åˆ«å¯¹ä¸¤æ•°ç»„è¿›è¡ŒäºŒåˆ†ã€‚ç”±äºæ•°ç»„æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥å…ˆç¡®å®šä¸¤ä¸ªæ•°ç»„çš„ä¸­ä½æ•°å¹¶æ¯”è¾ƒå¤§å°ï¼Œå¦‚æœé•¿çš„æ•°ç»„å¤§é‚£ä¹ˆéœ€è¦è®©iå˜å¤§ä»¥æ‰¾åˆ°å’Œé•¿æ•°ç»„ä¸­ä½æ•°æ¥è¿‘çš„å€¼ï¼Œç›´åˆ°æ‰¾åˆ°ä¸¤ä¸ªä¸­é—´çš„æ•°ã€‚

### æœ€é•¿å›æ–‡å­ä¸²

> ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œæ‰¾åˆ° `s` ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚ä½ å¯ä»¥å‡è®¾ `s` çš„æœ€å¤§é•¿åº¦ä¸º 1000ã€‚

~~~python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s)<2:
            return s
        length=len(s)
        maxStart=0
        maxEnd=0
        maxLen=1
        flags=[[False]*length for i in range(0,length) ]
        for r in range(1,length):
            for l in range(0,r):
                if s[l]== s[r] and (r-l<=2 or flags[l+1][r-1]):
                    flags[l][r]=True
                    if r-l+1>maxLen:
                        maxLen=r-l+1
                        maxStart=l
                        maxEnd=r
        return s[l:r+1]
                        
        
    def ishuiwen(self,s,i,j):
        for k in range(0,(i+j)//2):
            if s[i+k]!=s[j-k]:
                return False
        return True
            
        
        
~~~

ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³ï¼Œé‚£ä¹ˆé¦–å…ˆè¦æ‰¾åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œ$f(i,j)=(f(i-1,j+1)\quad and\quad s[i]==s[j])$ã€‚è€Œæˆ‘ä»¬æœ‰åˆå§‹çŠ¶æ€$f(i,i)=true\quad f(i,i+1)=(s[i]==s[i+1])$.ç”±æ­¤å¾—åˆ°é•¿åº¦ä¸º1å’Œ2 çš„å›æ–‡å­ä¸²ã€‚**è‡³æ­¤å¯ä»¥ç€æ‰‹å‡†å¤‡å·¥ä½œæ¯”å¦‚å°†flagsæ•°ç»„å¯¹è§’çº¿å…ˆåˆå§‹åŒ–ä¸ºtrueï¼Œä½†è¿™ä¸€æ­¥æ˜¯å¯ä»¥çœå»çš„ï¼Œå› ä¸ºä¸‹é¢çš„åˆ¤æ–­ä¸ä¼šå‚è€ƒå¯¹è§’çº¿çš„å€¼**ã€‚å½“éœ€è¦åˆ¤æ–­çš„å­—ç¬¦ä¸²é•¿åº¦å°äº3æ—¶ï¼Œå¯ä»¥ç›´æ¥åˆ¤å®šä¸ºå›æ–‡ä¸²ã€‚

å®é™…ä¸Šæˆ‘ç¬¬ä¸€æ¬¡å†™å‡ºçš„ä»£ç ä¸åŠ¨æ€è§„åˆ’å·®è·å°±åœ¨æˆ‘æ¯ä¸€æ¬¡éƒ½éœ€è¦åˆ¤æ–­å½“å‰æ‰¾åˆ°çš„å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›æ–‡ï¼Œä¹Ÿå°±å¤šäº†ä¸€å±‚åˆ¤æ–­å¯¼è‡´æ—¶é—´å¤æ‚åº¦ç”±$Oï¼ˆn^2ï¼‰$å˜ä¸ºäº†$O(n^3)$,é‚£ä¹ˆåŠ¨æ€è§„åˆ’å°±æ˜¯å°†ä¸Šä¸€æ¬¡çš„ç»“æœå­˜å‚¨èµ·æ¥ï¼Œå¦‚æœä¸Šä¸€æ¬¡æ˜¯é‚£ä¹ˆå¯ä»¥é€šè¿‡ä¸€æ¬¡åˆ¤æ–­ä¸¤è¾¹çš„å­—ç¬¦æ¥åˆ¤æ–­æ˜¯å¦è¿˜æ˜¯å›æ–‡å­—ç¬¦ä¸²ã€‚è¿™æ˜¯å…¸å‹çš„ä»¥æ—¶é—´æ¢ç©ºé—´çš„æ€æƒ³ã€‚

### æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œä¸€ä¸ªå­—ç¬¦è§„å¾‹ pï¼Œè¯·ä½ æ¥å®ç°ä¸€ä¸ªæ”¯æŒ '.' å’Œ '*' çš„æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚
>
> '.' åŒ¹é…ä»»æ„å•ä¸ªå­—ç¬¦
> '*' åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ 
> æ‰€è°“åŒ¹é…ï¼Œæ˜¯è¦æ¶µç›– æ•´ä¸ª å­—ç¬¦ä¸² sçš„ï¼Œè€Œä¸æ˜¯éƒ¨åˆ†å­—ç¬¦ä¸²ã€‚
>
> è¯´æ˜:
>
> s å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ã€‚
> p å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ï¼Œä»¥åŠå­—ç¬¦ . å’Œ *ã€‚

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        if not p:
            return not s
        s_length=len(s)
        p_length=len(p)

        dp=[[False]*(p_length+1) for _ in range(0,s_length+1)]
        dp[0][0]=True
        for i in range(1,p_length,2):
            if p[i]=='*':
                dp[0][i+1]=True
            else:
                break
        for i in range(0,s_length):
            for j in range(0,p_length):
                if s[i]==p[j] or p[j]=='.':
                    dp[i+1][j+1]=dp[i][j]
                elif p[j]=='*':
                    if s[i]==p[j-1] or p[j-1]=='.':
                        dp[i+1][j+1]=dp[i+1][j] or dp[i][j+1] or dp[i+1][j-1]
                    else:
                        dp[i+1][j+1]=dp[i+1][j-1]
        return dp[s_length][p_length]
```

çŠ¶æ€:$dp[i][j]$è¡¨ç¤ºèƒ½sçš„å‰iä½å¦ç”¨pçš„å‰jä½è¡¨ç¤º

çŠ¶æ€è½¬ç§»æ–¹ç¨‹:

1. $s[i]==p[j]$   é‚£ä¹ˆ $dp[i][j]$=$dp[i-1][j-1]$
2. $s[i]!=p[j]$ é‚£ä¹ˆå¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç§æƒ…å†µ
   1. $p[j]=='.'$   é‚£ä¹ˆ $dp[i][j]$=$dp[i-1][j-1]$
   2. $p[j]=='*'$   åˆ™åˆå¯ä»¥åˆ†ä¸ºå‡ ç§æƒ…å†µ
      	1. $s[i]==p[j-1]\quad or \quad p[j-1]=='.'$  é‚£ä¹ˆ$dp[i][j]= (dp[i][j-1]\quad or \quad dp[i-1][j] \quad or \quad dp[i][j-2])$
       	2. $s[i]!=p[j-1]\quad$ é‚£ä¹ˆ$dp[i][j] = dp[i][j-2]$ â€‹
   3. å¦åˆ™    $dp[i][j]=false$    

é‚£ä¹ˆå¦‚ä½•å¾—åˆ°åˆå§‹çŠ¶æ€å‘¢ï¼Œåˆå§‹çŠ¶æ€åº”è¯¥æœ‰å‡ ä½å‘¢ï¼Œæˆ‘è®¤ä¸ºè‡³å°‘è¦åˆå§‹åŒ–2nä½ï¼Œå› ä¸º*çš„å­˜åœ¨ã€‚

**PS**:åŸè®¡åˆ’æ˜¯æŠŠåŠ›æ‰£ä¸Šç²¾é€‰é¢è¯•é¢˜åšä¸€éï¼Œä½†å‘ç°è‡ªå·±åŠ¨æ€è§„åˆ’å±å®èœï¼Œæ‰€ä»¥æœ€è¿‘å‡†å¤‡æŠŠåŠ¨æ€è§„åˆ’çš„é¢˜åˆ·ä¸€åˆ·

### æœ€é•¿æœ‰æ•ˆæ‹¬å·

> ç»™å®šä¸€ä¸ªåªåŒ…å« `'('` å’Œ `')'` çš„å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºæœ€é•¿çš„åŒ…å«æœ‰æ•ˆæ‹¬å·çš„å­ä¸²çš„é•¿åº¦ã€‚

æ¶‰åŠæ‹¬å·çš„ä¸€å¾‹ç”¨æ ˆå°±å®Œäº‹äº†ï¼Œä½†æˆ‘æ˜¯æƒ³ç»ƒåŠ¨æ€è§„åˆ’çš„ï¼Œæ‰€ä»¥ç”¨dpçš„æ–¹æ³•ï¼Œä¸€å¼€å§‹æ€ä¹ˆä¹Ÿæƒ³ä¸åˆ°çŠ¶æ€æè¿°ï¼Œä¸€ç›´ä»¥ä¸ºdpå°±å¿…é¡»äºŒç»´æ•°ç»„,ä½†è¿™æ ·æ—¶é—´å¤æ‚åº¦ä¹Ÿå¿…ä¸º$O(n^2)$ï¼Œçœ‹äº†é¢˜è§£çŸ¥é“å¯ä»¥ç”¨iä½œä¸ºå³å€¼ï¼Œdp[i]ä½œä¸ºé•¿åº¦ï¼Œè¿™æ ·æ„å»ºäº†ä¸€ä¸ªé•¿åº¦ä¸ºnçš„å­˜å‚¨æ•°ç»„ã€‚

çŠ¶æ€: $dp[i]$ è¡¨ç¤ºsä»¥ä½ç½® i ç»“å°¾çš„é•¿åº¦ä¸º$dp[i]$çš„å­—ç¬¦ä¸²æ˜¯æœ‰æ•ˆæ‹¬å·å­—ç¬¦ä¸²

çŠ¶æ€è½¬ç§»æ–¹ç¨‹:

1. s[i]=')' and s[i-1] = '(' é‚£ä¹ˆ  $dp[i]=dp[i-2]+2$
2. s[i]=')' and s[i-1]=')' é‚£ä¹ˆå¯ä»¥æ¨å‡º   å¦‚æœ$s[i-dp[i-1]-1]='('$   åˆ™æœ‰$dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]$
3. å¦åˆ™ï¼Œ$dp[i]=0$

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        length=len(s)
        if length==0:
            return 0
        dp=[0]*length
        for i in range(1,length):
            if s[i]==')' and s[i-1]=='(':
                dp[i]=dp[i-2]+2
            elif s[i]==')' and s[i-1]==')':
                if i-dp[i-1]-1>=0 and s[i-dp[i-1]-1]=='(':
                    dp[i]=dp[i-1]+2+dp[i-dp[i-1]-2]
        return max(dp)
```

### é€šé…ç¬¦åŒ¹é…

> ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² (s) å’Œä¸€ä¸ªå­—ç¬¦æ¨¡å¼ (p) ï¼Œå®ç°ä¸€ä¸ªæ”¯æŒ '?' å’Œ '*' çš„é€šé…ç¬¦åŒ¹é…ã€‚
>
> '?' å¯ä»¥åŒ¹é…ä»»ä½•å•ä¸ªå­—ç¬¦ã€‚
> '*' å¯ä»¥åŒ¹é…ä»»æ„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬ç©ºå­—ç¬¦ä¸²ï¼‰ã€‚
> ä¸¤ä¸ªå­—ç¬¦ä¸²å®Œå…¨åŒ¹é…æ‰ç®—åŒ¹é…æˆåŠŸã€‚

è¿™é“é¢˜ä¸æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ç±»ä¼¼ï¼ŒåŠ¨æ€è§„åˆ’çš„æ€è·¯ä¹Ÿç±»ä¼¼

çŠ¶æ€: $dp[i][j]$ è¡¨ç¤ºsçš„å‰iä¸ªå­—ç¬¦ä¸pçš„å‰jä¸ªå­—ç¬¦åŒ¹é…  å¯çŸ¥$dp[0][0]=True$

çŠ¶æ€è½¬ç§»: 

1. $s[i]==p[j]\quad or \quad p[j]=='?'\quad or \quad p[j]=='*'$ é‚£ä¹ˆ $dp[i+1][j+1] or=dp[i][j]$
2. $s[i]!=p[j]\quad and \quad p[j-1]=='*'$  $dp[i+1][j] or= dp[i][j] \quad or \quad dp[i+1][j]$
3. $p[j]=='*' \quad and \quad s[i]=p[j+1]$ é‚£ä¹ˆ $dp[i+1][j+2]=dp[i][j]$

çŠ¶æ€åˆå§‹åŒ–:

ç”±äº*å¯ä»¥åŒ¹é…ä»»æ„å­—ç¬¦ï¼Œä¸ºé¿å…**çš„å‡ºç°,æ‰€ä»¥å…ˆæŠŠpä¸­çš„è¿ç»­æ˜Ÿå·åˆå¹¶ã€‚

~~~python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        i = 0
        while i < len(p) - 1:
            if p[i] == '*' and p[i + 1] == '*':
                p=p[0:i+1]+p[i+2:]
            else:
                i += 1

        s_len = len(s)
        p_len = len(p)
        if p_len == 0 and s_len == 0:
            return True
        elif p_len==0:
            return False
        dp = [[False] * (p_len + 1) for _ in range(0, s_len + 1)]
        dp[0][0] = True
        if p[0] == '*':
            for i in range(0,s_len+1):
                dp[i][1]=True
        for i in range(0, s_len):
            for j in range(0, p_len):
                if s[i] == p[j] or p[j] == '?' or p[j] == '*':
                    dp[i + 1][j + 1] = dp[i][j] or dp[i + 1][j + 1]
                if p[j] == '*':
                    dp[i + 1][j + 1] = dp[i + 1][j + 1] or dp[i][j + 1] or dp[i+1][j]
                if j - 1 >= 0 and p[j - 1] == '*':
                    dp[i + 1][j] = dp[i][j] or dp[i + 1][j]
                if p[j] == '*' and j + 1 < p_len and s[i] == p[j + 1]:
                    dp[i + 1][j + 2] = dp[i][j]
        return dp[s_len][p_len]
            
                
~~~

### ä¸åŒè·¯å¾„

> ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚
>
> æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚
>
> é—®æ€»å…±æœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ
>

ä¸€é“å…¸å‹çš„å›æº¯æœç´¢é—®é¢˜ï¼Œä½†è¦ç»ƒåŠ¨æ€è§„åˆ’å˜›ï¼Œç™¾æ€ä¸å¾—å…¶è§£ï¼ŒçŠ¶æ€åº”è¯¥æ€ä¹ˆå®šä¹‰ï¼ŒåŠ¨æ€è§„åˆ’æ˜¯å­˜å‚¨çš„ç­”æ¡ˆï¼Œæœ¬é¢˜è¦æ±‚ç»™å‡ºè·¯å¾„æ•°é‡ï¼Œé‚£ä¹ˆå­˜å‚¨çš„ä¹Ÿåº”å½“æ˜¯æ•°é‡ã€‚

çŠ¶æ€: $dp[i][j]$ è¡¨ç¤º åŸç‚¹åˆ°ç‚¹ (i,j)çš„è·¯å¾„æ•°é‡ã€‚

çŠ¶æ€è½¬ç§»ï¼š$dp[i][j]=dp[i-1][j]+dp[i][j-1]$  è¡¨ç¤ºå½“å‰ç‚¹è·¯å¾„æ•°é‡ç­‰äºä¸Šè¾¹å’Œå·¦è¾¹è·¯å¾„æ•°é‡ä¹‹å’Œ

çŠ¶æ€åˆå§‹åŒ–: $dp[:][0]=1 \quad dp[0][:]=1$

~~~python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp=[]
        for i in range(0,m):
            now=[]
            for j in range(0,n):
                if i==0 or j==0:
                    now.append(1)
                else:
                    now.append(0)
            dp.append(now)
        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]=dp[i-1][j]+dp[i][j-1]
        return dp[-1][-1]
~~~

**PS:** åšå®Œè¿™å‡ é“é¢˜ååˆåšäº†å‡ ä¸ªåŠ¨æ€è§„åˆ’çš„é¢˜ï¼Œæ„Ÿè§‰éƒ½å¾ˆç®€å•ç›´æ¥åœ¨åŠ›æ‰£ç½‘é¡µä¸Šç›´æ¥å†™å‡ºæ¥çš„ï¼Œç„¶åæ¥äº†ä¸ªéš¾çš„ã€‚

### ç¼–è¾‘è·ç¦»

> ç»™å®šä¸¤ä¸ªå•è¯ word1 å’Œ word2ï¼Œè®¡ç®—å‡ºå°† word1 è½¬æ¢æˆ word2 æ‰€ä½¿ç”¨çš„æœ€å°‘æ“ä½œæ•° ã€‚
>
> ä½ å¯ä»¥å¯¹ä¸€ä¸ªå•è¯è¿›è¡Œå¦‚ä¸‹ä¸‰ç§æ“ä½œï¼š
>
> æ’å…¥ä¸€ä¸ªå­—ç¬¦
> åˆ é™¤ä¸€ä¸ªå­—ç¬¦
> æ›¿æ¢ä¸€ä¸ªå­—ç¬¦

çŠ¶æ€: $dp[i][j]$ word1å‰iä¸ªå­—ç¬¦è½¬æ¢ä¸ºword2å‰jä¸ªå­—ç¬¦éœ€è¦çš„æœ€å°æ­¥æ•°

çŠ¶æ€è½¬ç§»: 

1. $word1[i]==word2[j]$ é‚£ä¹ˆ $dp[i+1][j+1]=min(dp[i][j],dp[i][j+1]+1,dp[i+1][j]+1)$
2. $!=$ é‚£ä¹ˆ $dp[i+1][j+1]=min(dp[i][j]+1,dp[i][j+1]+1,dp[i+1][j]+1)$

çŠ¶æ€åˆå§‹åŒ–: æˆ‘ä¸€å¼€å§‹åªå°†$dp[0][0]$åˆå§‹åŒ–ä¸º0ï¼Œä½†ç»“æœé”™è¯¯ï¼ŒæŸ¥çœ‹é¢˜è§£åå‘ç°é¢˜è§£å’Œæˆ‘çš„çŠ¶æ€è½¬ç§»ä¸€æ¨¡ä¸€æ ·ï¼Œä½†ä»–å°†$d[i][0]å’Œd[0][j]$åˆ†åˆ«åˆå§‹åŒ–ä¸ºiï¼Œjå¾—åˆ°æ­£ç¡®ç»“æœ. å› ä¸ºæˆ‘çš„æ“ä½œå¹¶ä¸ä¼šæŠŠç¬¬ä¸€åˆ—ä¸ç¬¬ä¸€è¡Œçš„çŠ¶æ€å€¼å¡«å…¥å¯¼è‡´é”™è¯¯ã€‚

~~~python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1=len(word1)
        len2=len(word2)
        dp=[[0]*(len2+1) for _ in range(0,len1+1)]
        dp[0][0]=0
        for i in range(len1 + 1):
            d[i][0] = i
        for j in range(len2 + 1):
            d[0][j] = j

        for i in range(0,len1):
            for j in range(0,len2):
                if word1[i]==word2[j]:
                    dp[i+1][j+1]=min(dp[i][j],dp[i][j+1]+1,dp[i+1][j]+1)
                else:
                    dp[i+1][j+1]=min(dp[i][j]+1,dp[i][j+1]+1,dp[i+1][j]+1)
        return dp[-1][-1]
~~~

**PS:**é¢˜ä¸»è§‰å¾—è‡ªå·±å°æˆäº†ï¼Œä¸€äº›ç®€å•çš„å¯ä»¥ç›´æ¥åœ¨åŠ›æ‰£ç½‘ç«™å†™å¾—å°±æ²¡æœ‰å†å†™æ€è·¯äº†

### æ‹¬å·ç”Ÿæˆ

> ç»™å‡º *n* ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ å†™å‡ºä¸€ä¸ªå‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸”**æœ‰æ•ˆçš„**æ‹¬å·ç»„åˆã€‚

æœ¬é¢˜å°±æ˜¯æ’å…¥ï¼Œå¯¹äºä¸€ä¸ªåˆæ³•çš„æ‹¬å·å­—ç¬¦ä¸²ï¼Œèƒ½æ’å…¥çš„ä½ç½®æœ‰ä¸‰ä¸ªï¼Œå·¦æ‹¬å·å·¦è¾¹ï¼Œå³æ‹¬å·å³è¾¹ï¼Œæ‹¬å·ä¸­é—´ã€‚å¹¶ä¸”æ‹¬å·åº”å½“æˆå¯¹æ’å…¥ã€‚

~~~python
# ä¸€å¼€å§‹çš„æš´åŠ›æ³•ï¼Œç”±äºé‡å¤çŠ¶æ€å¤ªå¤šå¯¼è‡´è¶…æ—¶
class Solution:
    def generateParenthesis(self, n: int):
        if n==1:
            return ['()']
        d={}
        def digui(nowStr,num):
            if num==0:
                d[nowStr]=0
                return
            for i in range(0,len(nowStr)):
                if nowStr[i]=='(':
                    digui(nowStr[0:i]+'()'+nowStr[i:],num-1)
                    if nowStr[i+1]==')':
                        digui(nowStr[0:i+1]+'()'+nowStr[i+1:],num-1)
                if nowStr[i]==')':
                    digui(nowStr[0:i+1] + '()' + nowStr[i+1:], num - 1)
        digui('()',n-1)
        return d.keys()               
~~~

~~~python
# å®˜æ–¹é¢˜è§£çš„é«˜æ•ˆåšæ³•
class Solution(object):
    def generateParenthesis(self, N):
        ans = []
        def backtrack(S = '', left = 0, right = 0):
            if len(S) == 2 * N:
                ans.append(S)
                return
            if left < N:
                backtrack(S+'(', left+1, right)
            if right < left:
                backtrack(S+')', left, right+1)

        backtrack()
        return ans
~~~

å®˜æ–¹é¢˜è§£æœç„¶è¿˜æ˜¯ç®€æ´é«˜æ•ˆï¼Œæ¯”æˆ‘ç­‰fiveé«˜åˆ°ä¸çŸ¥å“ªé‡Œå»äº†ã€‚ä¸»è¦æ˜¯é¿å…äº†é‡å¤çŠ¶æ€çš„ç”Ÿæˆå’Œåˆ¤æ–­ã€‚

**å…¶å®å†™åˆ°è¿™é‡Œæ´‹æ´‹æ´’æ´’4000å­—ï¼Œå‡ ä¹å·²ç»æŠŠé«˜æ•ˆé¢˜è§£çš„æ€è·¯æ‰¾å®Œäº†ï¼Œæ— å¤–ä¹äºŒåˆ†æ³•ã€åŠ¨æ€è§„åˆ’çš„æ•°ç»„å­˜å‚¨çŠ¶æ€ä»¥ç©ºé—´æ¢æ—¶é—´ã€å“ˆå¸Œè¡¨ä»¥ç©ºé—´æ¢æ—¶é—´å’Œå›æº¯æ—¶é¿å…é‡å¤çŠ¶æ€ã€‚**

### æ¥é›¨æ°´

> ç»™å®š *n* ä¸ªéè´Ÿæ•´æ•°è¡¨ç¤ºæ¯ä¸ªå®½åº¦ä¸º 1 çš„æŸ±å­çš„é«˜åº¦å›¾ï¼Œè®¡ç®—æŒ‰æ­¤æ’åˆ—çš„æŸ±å­ï¼Œä¸‹é›¨ä¹‹åèƒ½æ¥å¤šå°‘é›¨æ°´ã€‚

å¯¹äºæ¯ä¸€æ ¹æŸ±å­ï¼Œå¦‚æœæƒ³è¦ç››æ°´ï¼Œé‚£ä¹ˆå·¦å³ä¸¤ä¾§å¿…é¡»æœ‰è‡³å°‘ä¸€ä¸ªæ¯”ä»–é«˜çš„æŸ±å­ï¼Œå¦åˆ™å¿…æ¼æ°´ã€‚å¦‚æœå·¦å³ä¸¤ä¾§éƒ½æœ‰æ¯”ä»–é«˜çš„æŸ±å­ï¼Œé‚£ä¹ˆé€‰å–è¾ƒçŸ®çš„æŸ±å­ï¼Œå‡å»å…¶å€¼ï¼Œæœ¨æ¡¶æ•ˆåº”ã€‚å¦‚æœä¹ˆå¾—ï¼Œé‚£å°±é€‰è‡ªå·±ï¼Œè‡ªå·±-è‡ªå·±=0.

æ³•ä¸€ï¼šæš´åŠ›æ³•

æŒ‰ç…§åˆšåˆšçš„æ€è·¯ï¼Œé‚£ä¹ˆå¯¹æ¯ä¸ªæŸ±å­éƒ½è®¡ç®—è‡ªå·±å¤´ä¸Šçš„æ°´å³å¯ã€‚

~~~python
    def trap(self, height) -> int:
        length = len(height)
        res=0
        if length < 3:
            return 0
        for i in range(1,length):
            max_left=0
            max_right=0
            for j in range(i,-1,-1):
                max_left=max(height[j],max_left)
            for j in range(i,length):
                max_right=max(height[j],max_right)
            res+=min(max_right,max_left)-height[i]
        return res
~~~

æ³•äºŒï¼šåŠ¨æ€ç¼–ç¨‹æ³•

æˆ‘ä»¬çŸ¥é“ï¼Œå…¶å®å¯¹äºä¸€ä¸ªç»™å®šçš„æ•°ç»„ï¼Œæ¯ä¸€æ ¹æŸ±å­çš„å·¦å³æœ€é«˜æŸ±å­æ˜¯å¯ä»¥å¾—åˆ°çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…ˆæŠŠè¿™äº›æœ€é«˜æŸ±å­ä¿å­˜åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­ï¼Œç­‰åˆ°æœ€ååœ¨å–å‡ºä½¿ç”¨ï¼Œè¿™æ ·å‡å°‘äº†æ—¶é—´å¤æ‚åº¦ã€‚

~~~python
class Solution:
    def trap(self, height: List[int]) -> int:
        length=len(height)
        if length < 3:
            return 0
        l_max=[0]* length   
        r_max= [0]* length
        l_max[0]=height[0]
        r_max[-1]=height[-1]
        res=0
        for i in range(1,length):
            l_max[i]=(max(l_max[i-1],height[i]))
        for i in range(length-2,-1,-1):
            r_max[i]=max(r_max[i+1],height[i])
        for i in range(1,length):
            res+=min(l_max[i],r_max[i])-height[i]
        return res
~~~

è¿™æ ·æ—¶é—´å¤æ‚åº¦å…¶å®æ˜¯$O(3n)$ é‚£ä¹ˆæœ‰æ²¡æœ‰æ›´å¿«çš„æ–¹æ³•å‘¢ï¼Œä¸‹é¢æ˜¯åŒæŒ‡é’ˆæ³•ï¼š

å’Œæ–¹æ³• 2 ç›¸æ¯”ï¼Œæˆ‘ä»¬ä¸ä»å·¦å’Œä»å³åˆ†å¼€è®¡ç®—ï¼Œæˆ‘ä»¬æƒ³åŠæ³•ä¸€æ¬¡å®Œæˆéå†ã€‚

~~~c++
int trap(vector<int>& height)
{
    int left = 0, right = height.size() - 1;
    int ans = 0;
    int left_max = 0, right_max = 0;
    while (left < right) {
        if (height[left] < height[right]) {
            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
            ++left;
        }
        else {
            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
            --right;
        }
    }
    return ans;
}
~~~



### æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—

æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚è¾“å…¥ä¸€ä¸ªé€’å¢æ’åºçš„æ•°ç»„çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¾“å‡ºæ—‹è½¬æ•°ç»„çš„æœ€å°å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„ `[3,4,5,1,2]` ä¸º `[1,2,3,4,5]` çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¯¥æ•°ç»„çš„æœ€å°å€¼ä¸º1ã€‚ 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼š[3,4,5,1,2]
è¾“å‡ºï¼š1
```

**ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼š[2,2,2,0,1]
è¾“å‡ºï¼š0
```

~~~python
class Solution:
    def minArray(self, nums: List[int]) -> int:
        n = len(nums)
        if n==1:
            return nums[0]
        if nums[0]<nums[n-1]:
            return nums[0]
        i=0
        j=n-1
        while i<j:
            middle =(i+j)//2
            # è¿™é‡Œéœ€è¦ä¸­é—´çš„å’Œå³ä¾§æ¯”è¾ƒï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯å¯¹jè‡ªå³å‘å·¦ç§»åŠ¨çš„
            if nums[middle]>nums[j]:
                i=middle+1
            elif nums[middle]<nums[j]:
                # middleå¯ä»¥ï¼Œä½†middle-1å´ä¼šå‡ºé—®é¢˜
                j=middle
            else:
                j-=1
        return nums[i]
            
~~~

æœ¬é¢˜ä¸€çœ‹å°±çŸ¥é“æ˜¯äºŒåˆ†æ³•ï¼Œä½†æ˜¯è¿˜æœ‰ä¸€äº›ç»†èŠ‚éœ€è¦è€ƒè™‘ï¼Œæ¯”å¦‚å¦‚æœæ—‹è½¬0ä¸ªå…ƒç´ æ€ä¹ˆåŠï¼Œå¦‚æœæœ‰é‡å¤æ•°å­—æ€ä¹ˆåŠã€‚å¾ˆå¤šæˆ‘ä»¬éœ€è¦è€ƒè™‘çš„å†…å®¹éƒ½åœ¨æµ‹è¯•ç”¨ä¾‹ä¸­ã€‚

#### é¢è¯•é¢˜20. è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²

> è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¡¨ç¤ºæ•°å€¼ï¼ˆåŒ…æ‹¬æ•´æ•°å’Œå°æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²"+100"ã€"5e2"ã€"-123"ã€"3.1416"ã€"0123"åŠ"-1E-16"éƒ½è¡¨ç¤ºæ•°å€¼ï¼Œä½†"12e"ã€"1a3.14"ã€"1.2.3"ã€"+-5"åŠ"12e+5.4"éƒ½ä¸æ˜¯ã€‚

è¿™é¢˜æˆ‘å†™çš„å¹¶ä¸ç®€æ´ï¼Œæƒå½“åšä¸ªè®°å½•ï¼ŒæŒºæ¶å¿ƒçš„ï¼Œå„ç§å¼‚å¸¸å€¼ã€‚

"1 "æ³¨æ„åˆ°è¿™ä¸ªç©ºæ ¼äº†å—ï¼Œæˆ‘æŠŠä»–ğŸ´æ€äº†

".1" è™½ç„¶å¯ä»¥ç†è§£ï¼Œä½†è¿˜æ˜¯å¾ˆæ¶å¿ƒï¼Œæ²¡æœ‰æå‰å‘ŠçŸ¥ã€‚

~~~python
class Solution:
    def isNumber(self, s: str) -> bool:
        dotNum =0
        s=s.strip()
        if len(s)==0:
            return False
        if s[0]=='+' or s[0]=='-':
            s=s[1:]
        if len(s)>0 and s[0]=='.':
            s=s[1:]
            dotNum+=1
        if len(s)>0 and s[0].isdigit():
            pass
        else:
            return False 
        while len(s)>0:
            if not s[0].isdigit():
                if s[0]=='.' and dotNum==0:
                    dotNum+=1
                elif s[0]=='e':
                    s=s[1:]
                    if len(s)==0:
                        return False
                    else:
                        break
                else:
                    return False            
            s=s[1:]
        if len(s)>0:
            if (s[0]=='+' or s[0]=='-') and len(s)>1:
                s=s[1:]
            while len(s)>0:
                if not s[0].isdigit():
                    return False
                s=s[1:]
        return True
~~~

