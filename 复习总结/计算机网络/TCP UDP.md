## TCP UDP

### TCP 状态转移

#### 三次握手

![img](http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png)

​    （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
​    （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
​    （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

1. 序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记
2. 确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
3. 标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
           （A）URG：紧急指针（urgent pointer）有效。
           （B）ACK：确认序号有效。
           （C）PSH：接收方应该尽快将这个报文交给应用层。
           （D）RST：重置连接。
           （E）SYN：发起一个新连接。
           （F）FIN：释放一个连接。

#### 四次挥手

![img](http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png)

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
    （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
    （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
    （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
    （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

#### 拥塞处理

计算机网络中的带宽、交换节点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。

慢启动算法：因为不清楚网络状况，所以需要进行试探，将发送窗口逐渐增大，也就是逐渐增大拥塞窗口的数值。在刚开始发送的时候，先把拥塞窗口CWND设置为最大报文段MSS，每收到一个对新报文段的确认后，就把拥塞窗口最多增加一个MSS数值。这种逐步增大的方法可以使分组注入到网络的速率更加合理。【指数增长】

为了防止拥塞窗口过大引起网络拥塞，我们需要设置一个慢开始门限ssthreth状态变量，当cwnd < ssthreth时，使用慢开始算法；当cwnd > ssthrerth时，使用拥塞控制算法；如果两者相等，两个都可以使用。

慢启动的“慢”并不是指CWND增长速率慢而是说在TCP开始发送报文时，先设置CWND=1，使发送端开始时只发送一个报文段进行探测。

（2）拥塞避免
就是让拥塞窗口缓慢增大，即每经过一个往返时间RTT就使cwnd+1，这种线性增长的速率慢很多。
只要发送方判断出网络拥塞，不论是在慢开始还是拥塞控制阶段，都要把慢开始门限值设置为出现拥塞时发送端窗口大小的一半，但不能小于2。然后把cwnd重新置为1，执行慢开始算法。
门限值减半，cwnd重置为1，做目的是减少发送到网络中的分组数，使得发生拥塞的路由器能够有时间能把队列中积压的分组处理掉。
发送端判断网络拥塞的依据：
①传送超时，即TCP重传定时器溢出
②收到重复的确认报文

（3）快重传
快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。发送方只要一连收到3个同样的确认报文就应当立即重传数据报，不必等待报文段的重传计时器到期。

（4）快恢复
把慢开始门限减半，“乘法减小”，将cwnd设置为新的慢开始门限值，继续执行拥塞避免算法，“加法增大”

#### TIME_WAIT

所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

#### close_wait

**1.close_wait状态介绍**：

客户端主动关闭连接，服务器接收到客户端的FIN，但是还没有发送自己的FIN，此时的状态为close_wait状态，大量的close_wait状态拖累服务器性能

**2.close_wait产生的原因**：

某种情况下客户端关闭了连接，但是我方忙于读写，没有关闭连接

**3.解决方法**：

思想：检查出客户端已经关闭的连接，关闭他

之所以会出现这种问题，肯定是服务器端的连接释放的代码存在问题

1.当服务器读写失败时，可以选择关闭连接

2.定期向连接发送询问数据，检查收到的回复数据包（Heart-Beat线程发送指定格式的心跳数据包）

3.修改keep-live参数(超时时间，tcp检查间隔时间:keeplive探测包发送的间隔，tcp检查次数:如果对方不予应答，探测包发送的次数）

#### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 流量控制

如果发送端发送数据太快，接收端来不及接收，可能会丢失数据。所以流量控制是让发送端不要发送太快，要让接收端来得及接收
流量控制是通过大小可变的滑动窗口实现的。
发送端窗口大小不能超过接收端窗口大小的值。TCP窗口单位是字节。
为什么要设置窗口，因为如果TCP发完一次数据等待接收端确认再发下一条数据太慢了。
由图中可知，TCP三次流量控制分别是，第一次窗口大小由400减到300，第二次减到100，第三次减到0。
TCP连接的一方如果收到**零窗口**通知，就会启动坚持计时器。若坚持计时器的时间到期，就会发送一个零窗口控测报文段，收到报文段的一方就重新设置坚持计时器。

### TCP与UDP区别

TCP与UDP区别总结：

1、TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接

```
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
```

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。

**UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)**
**TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)**

### 粘包拆包

UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。
粘包、拆包发生原因
发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，
1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
等等。
粘包、拆包解决办法
通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：
1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

### UDP实现TCP

添加seq/ack机制，确保数据发送到对端
添加发送和接收缓冲区，主要是用户超时重传
添加超时重传机制
详细说明：发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。
