## 多线程和锁

### 线程池

线程池是管理一组同构工作线程的资源池。合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 锁机制

实现锁机制，主要是实现共享数据的互斥性和可见性,**互斥性**即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块进行访问。互斥性也称作操作的原子性。常见的实现方式有synchorized。**可见性**：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。常见的实现方式有volatile。

1. Synchronized

   该关键字的使用场景可分为 **对象锁**和**类锁**

   对象锁：同步代码块或同步非静态方法，示例如下：

   ~~~java
   
   public class SynchronizedObectCodeBlock2 implements Runnable {
    
   	static SynchronizedObectCodeBlock2 instance = new SynchronizedObectCodeBlock2();
    
   	public static void main(String[] args) throws InterruptedException {
   		Thread th1 = new Thread(instance);
   		Thread th2 = new Thread(instance);
   		th1.start();
   		th2.start();
   		while (th1.isAlive() || th2.isAlive()) {
   		}
   		System.out.println("finished");
   	}
    
   	@Override
   	public void run() {
   		synchronized (this) {
    
   			// Thread.currentThread（）当前线程，.getName（）名字
   			System.out.println("我是对象锁的代码块形式我叫" + Thread.currentThread().getName());
   			try {
   				// 让线程休眠3秒
   				Thread.sleep(3000);
   			} catch (InterruptedException e) {
   				// TODO Auto-generated catch block
   				e.printStackTrace();
   			}
    
   			System.out.println(Thread.currentThread().getName() + "运行结束");
   		}
   	}
   }
   ~~~

   ~~~java
   public class SynchronizedObectMethod3 implements Runnable{
   	static SynchronizedObectMethod3 intance=new SynchronizedObectMethod3();
   	public static void main(String[] args) {
   		Thread th1=new Thread(intance);
   		Thread th2=new Thread(intance);
   		th1.start();
   		th2.start();
   		while(th1.isAlive() || th2.isAlive()){
   			System.out.println("finished");
   		}
    
   	}
   	public void run() {
   		method();
   	}
   	public synchronized void method(){
   		System.out.println("我是对象锁的方法修饰符形式，我叫："+Thread.currentThread().getName());
   		try {
   			Thread.sleep(3000);
   		} catch (InterruptedException e) {
   			// TODO Auto-generated catch block
   			e.printStackTrace();
   		}
   		System.out.println(Thread.currentThread().getName()+"结束");
   	}
    
   }
   ~~~

   类锁：只能在同一时刻被这个类的一个对象拥有

   可以加在静态方法或者代码块中

   ~~~java
   
   	private void method() {
   		synchronized (SynchronizeClassClass5.class) {
   			System.out.println("我是类锁的第二种形式，synchronize（*.class），我叫" + Thread.currentThread().getName());
   			try {
   				Thread.sleep(3000);
   			} catch (InterruptedException e) {
   				// TODO Auto-generated catch block
   				e.printStackTrace();
   			}
   			System.out.println(Thread.currentThread().getName()+"结束");
   		}
       }
    
   ~~~

   

2. lock

   看网上的博客后，我的理解是lock相当于自己定义的升级版的mutex，我们可以自由的调用lock.lock()函数实现对代码片段的加锁和lock.unlock()解锁。

3. ReentrantLock

   ReentrantLock称为重入锁，位于JUC包的locks。是lock的一个子类，能够实现比synchronized更细粒度的控制，比如控制公平性。此外需要注意，调用lock（）之后，必须调用unlock（）释放锁。它的性能未必比synchronized高，并且是可重入的。

4. volatile

   **被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。** 

   在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出**Lock前缀的指令**。作用是 将当前处理器缓存行的数据写回系统内存；和这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效。

   为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。



### synchronized与Lock的区别

1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）

6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。