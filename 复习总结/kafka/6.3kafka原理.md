### kafka

Broker：服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的Kafka服务节点或Kafka服务实例。大多数情况下也可以将Broker看作一台Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成了一个Kafka集群。一般而言，我们更习惯使用首字母小写的broker来表示服务代理节点。

Kafka中的分区可以分布在不同的服务器（broker）上，也就是说，一个主题可以横跨多个broker，以此来提供比单个broker更强大的性能。

每一条消息被发送到broker之前，会根据分区规则选择存储到哪个具体的分区。如果分区规则设定得合理，所有的消息都可以均匀地分配到不同的分区中。

Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。同一分区的不同副本中保存的是相同的消息（在同一时刻，副本之间并非完全一样），副本之间是“一主多从”的关系，其中leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。Kafka通过多副本机制实现了故障的自动转移，当Kafka集群中某个broker失效时仍然能保证服务可用。

### kafka生产者参数

#### acks

这个参数用来指定分区中必须要有多少个副本收到这条消息，之后生产者才会认为这条消息是成功写入的。acks 是生产者客户端中一个非常重要的参数，它涉及消息的可靠性和吞吐量之间的权衡。

#### max.request.size

这个参数用来限制生产者客户端能发送的消息的最大值，默认值为 1048576B，即 1MB。并且不建议随意增大这个参数的值。

#### retries和retry.backoff.ms

retries参数用来配置生产者重试的次数，默认值为0，即在发生异常的时候不进行任何重试动作。可以配置大于0的值进行重试，防止因网络抖动等因素造成发送失败。

retry.backoff.ms默认值是100ms,表示两次重试之间的时间间隔。

### 消费者和消费组

消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。

而主题中的分区会被消费组中的各个消费者平均分配，并且每个消费者只能消费被分配到的分区。

Kafka中的消费是基于拉模式的。消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用poll（）方法，而poll（）方法返回的是所订阅的主题（分区）上的一组消息。

#### 再均衡

再均衡是指分区的所属权从一个消费者转移到另一个消费者的行为，其为消费者组具备高可用和伸缩性提供保证。我们不用担心如果删除消费者组内的消费者，其已收到但未消费的消息如何处理。

再均衡时期中，消费组是不可用的，无法读取新消息。并且如果消费者消费消息后尚未提交消费位移就发生了再均衡操作，那这条消息会被重新消费一遍。

#### 多副本

只有leader副本对外提供读写服务，而follower副本只负责在内部进行消息的同步。一旦leader节点宕机，可以选举一个follower副本作为新的leader，如果follower和leader的相同分区在同一个节点，那也不用选举了，都直接不能用了，所以对同一个分区而言，同一个broker节点中不可能出现它的多个副本，即Kafka集群的一个broker中最多只能有它的一个副本。

即leader和follower的分区在同一个broker中不交叉。



以上直接选举的方法也会导致一个问题就是负载失衡，一旦发生宕机，进行选举后，可能一台机器承担两台机器的请求，所以kafka引入了优先副本的概念，给承载leader副本较少的节点。